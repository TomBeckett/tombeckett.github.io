[{"content":"A common complaint about Spring refers to Spring Magic and general confusion about how dependency injection works in Spring. It can be extremely confusing to get a stacktrace like this:\nError creating bean with name \u0026#39;beanA\u0026#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.example.demo.BeanB com.example.demo.BeanA.dependency; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.example.demo.BeanB] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} The challenges of Inversion of Control Inversion of Control (IoC) is a way to create an object without expressly creating or managing its dependencies.\nTo explain why you may want IoC, I\u0026rsquo;m going to use a common onion architecture example seen in many REST services.\nvar config = { startOnLoad: true, theme: 'neutral', align: 'left' }; mermaid.initialize(config);  flowchart LR RestController -- BusinessService -- PersistenceService -.- Database[(Database)] RestController -- AnotherBusinessService -- PersistenceService  Lets say we want to make a new instance of a RestController:\npublic class RestController { final BusinessService businessService; final AnotherBusinessService anotherBusinessService; public RestController() { var persistenceService = new PersistenceService(\u0026#34;someDatabaseConnection?\u0026#34;); businessService = new BusinessService(persistenceService); anotherBusinessService = new AnotherBusinessService(persistenceService); } } Thats.. fairly messy. We can imagine that as BusinessService expands to need more of its own dependencies we\u0026rsquo;re quickly going to get into maintainability issues.\n Where would you instantiate a common singleton across many controllers? What happens if PersistenceService has more of its own dependencies? Suddenly your passing dependencies of dependencies down many layers. As your application gets larger, you can imagine needing logging classes, database connections, etc. Thats a lot of crud in your constructors. This constructor logic can pollute downstream classes, violating the Single Responsibility Principle. Managing your own dependencies can cause circular dependency issues.  To give another example, imagine a scenario where you wanted a certain Database in production (MySQL) but a memory database locally (H2). In this circumstance you would need to put a nasty if somewhere in your code, depending on the environment.\nIts not.. bad but its not nice either. Lets see what other options we have available to us.\nSo what is a bean? A Bean is a Spring concept for an object that are under dependency management by the Spring Framework. Spring uses its own IoC Container that does this heavy lifting for you.\nTo register a bean you need to let Spring know what it should be managing and how it should be managed. In our example BusinessService, AnotherBusinessService and PersistenceService all should be managed. To do that, we need to use an Annotation.\n@Service // Added Spring annotation public class RestController { } By adding the @Service annotation we\u0026rsquo;re telling Spring that this class is a Business Service Facade aka its a business logic class and will be reused.\nAfter adding that annotation to the other classes, we can refactor our RestController.\npublic class RestController { @Autowired // Added Spring annotation  final BusinessService businessService; @Autowired // Added Spring annotation  final AnotherBusinessService anotherBusinessService; // Constructor has been removed. } We\u0026rsquo;ve added @Autowired and removed the constructor. I hope you will agree that this is much cleaner and ultimately maintainable. But how does Autowired work?\nWhen the application starts, Spring looks for usages of @Autowired. Then it looks for any registered beans, in our case they have been registered using @Service. It will then consolidate all dependencies to reuse as many as possible during its runtime.\n There are other annotations that could be used (@Component or @Repository) but @Service seems to most appropriate in this use case.\nCorrect annotations can be a good source for documentation.\n I hope you agree that an Inversion of control framework can make code much more sustainable and ultimately more stable.\nAn alternative Some people do not like this style of injection as they feel using @Autowired too much like \u0026lsquo;magic\u0026rsquo; and not close enough to regular Java.\nI suspect this comes down to \u0026ldquo;Are you okay with Annotations in Java?\u0026quot;.\nWhile Spring is very annotation heavy, the Spring team is now offering (and even recommending) constructor injection. This is far closer to regular Java and other languages:\npublic class RestController { final BusinessService businessService; final AnotherBusinessService anotherBusinessService; public RestController(BusinessService businessService, AnotherBusinessService anotherBusinessService) { this.businessService = businessService; this.anotherBusinessService = anotherBusinessService; } } Effectively Spring just \u0026lsquo;knows\u0026rsquo; about what a BusinessService is from the @Service annotation. This keeps the RestController clean and understandable, it also gives us flexibility by still having a constructor.\nI personally do prefer this style as it removes two annotations and makes the code a bit easier to understand. We also have a constructor we can now use in our unit tests if required.\nWhen it goes wrong There are a few things to look out for when it comes to Spring IoC.\nDon\u0026rsquo;t use new Any attempts to create an object manually will mean Spring ignores that object and all its descendants. This may seem obvious but effectively when you annotate a class with @Service, @Component or @Repository you are handing over ownership to Spring IoC to create and manage that class. Using the new keyword may cause errors as the objects dependency tree wont be properly created.\nIts very much all or nothing when it comes to Spring IoC. In certain circumstances this may be fine (such as unit testing) but overall, it\u0026rsquo;s best to avoid creating objects yourself and letting Spring handle it.\nYou\u0026rsquo;ve added another class to a constructor Using our example from above, if you add another class to the constructor but do not annotate with @Service you will see an error:\npublic class RestController { final BusinessService businessService; final AnotherBusinessService anotherBusinessService; final NewService newService; public RestController(BusinessService businessService, AnotherBusinessService anotherBusinessService, NewService newService) { this.businessService = businessService; this.anotherBusinessService = anotherBusinessService; this.newService = newService; // new service without @Service annotation!  } } // No annotation public class NewService() {} NewService is not known\u0026hellip;\nError creating bean with name \u0026#39;NewService\u0026#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.example.demo.NewService com.example.demo.NewService.dependency; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.example.demo.NewService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} In this situation adding @Service to NewService would register the class and allow Spring to manage this bean correctly.\n@Service // Annotation added. Bean should now be registered. public class NewService() {} The above error stacktrace is the same example from the introduction. I hope this makes feels more approachable now!\nUsing alternative services In this final example we want to vary which service we get depending on if we\u0026rsquo;re running locally or in production. This is exceptionally powerful.\nvar config = { startOnLoad: true, theme: 'neutral', align: 'left' }; mermaid.initialize(config);  flowchart LR RestController -- BusinessService -- LocalBusinessServiceImpl RestController -- BusinessService -- ProductionBusinessServiceImpl  First, we create a shared interface with each service having the @Service annotation.\npublic interface BusinessService { String getEnvironment(); } @Service public class LocalBusinessServiceImpl implements BusinessService { public String getEnvironment() { return \u0026#34;Local\u0026#34;; } } @Service public class ProductionBusinessServiceImpl implements BusinessService { public String getEnvironment() { return \u0026#34;Production\u0026#34;; } } public class RestController { final BusinessService businessService; public RestController(BusinessService businessService) { this.businessService = businessService; } } Now we have an issue if we start the application Spring will throw a stacktrace error similar to:\nDescription: Field businessService in com.example.demo.RestController required a single bean, but 2 were found: - businessService: defined by method \u0026#39;businessService\u0026#39; in class path resource [com/example/LocalBusinessServiceImpl.class] - businessService: defined by method \u0026#39;businessService\u0026#39; in class path resource [com/example/ProductionBusinessServiceImpl.class] Action: Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed Newcomers can get frustrated by the word bean and while the action appears clear, it does not help the programmer make a decision on where or why to add @Primary.\nWhats happening is Spring says \u0026ldquo;You have two possible candidates, which do you want to use?\u0026quot;. Remember that Spring IoC needs to know not only what but when to use a Bean.\nLets fix our code:\n// Interface and RestController unchanged.  @Profile(\u0026#34;dev\u0026#34;) // New annotation @Service public class LocalBusinessServiceImpl implements BusinessService { public String getEnvironment() { return \u0026#34;Local\u0026#34;; } } @Profile(\u0026#34;prod\u0026#34;) // New annotation @Service public class ProductionBusinessServiceImpl implements BusinessService { public String getEnvironment() { return \u0026#34;Production\u0026#34;; } } Here we\u0026rsquo;ve added a @Profile annotation to tell Spring when to use each bean.\nWe also could have also used one of the recommended actions from the previous stacktrace:\n// Interface, RestController unchanged.  @Service public class LocalBusinessServiceImpl implements BusinessService { public String getEnvironment() { return \u0026#34;Local\u0026#34;; } } @Profile(\u0026#34;!dev\u0026#34;) // If its not dev @Order(1) // Use this one first @Service public class ProductionBusinessServiceImpl implements BusinessService { public String getEnvironment() { return \u0026#34;Production\u0026#34;; } }  Remember, if you see a \u0026lsquo;bean\u0026rsquo; error its because Spring either has too many options or no options when configuring IoC.\n Conclusion I hope after this introduction to Spring you understand a bit more about:\n Why you should be using Spring\u0026rsquo;s inversion of control. How to configure a Spring Bean. Potential methods for resolving Spring bean stacktraces.  ","permalink":"https://tombeckett.github.io/posts/spring-magic/","summary":"A common complaint about Spring refers to Spring Magic and general confusion about how dependency injection works in Spring. It can be extremely confusing to get a stacktrace like this:\nError creating bean with name \u0026#39;beanA\u0026#39;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.example.demo.BeanB com.example.demo.BeanA.dependency; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.example.demo.BeanB] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency.","title":"Spring Boot: Magic Beans"},{"content":"Five years ago I moved to Spring Boot from ASP.NET. Frankly, I found Java and the Spring Framework confusing and it was not my choice to use it.\nSince then I\u0026rsquo;ve used many other backend technologies (Ruby on Rails, ASP.NET Core, Express/TypeScript) but I keep coming back to Spring. I\u0026rsquo;ve really had a change of heart with Spring.\nOver those years I\u0026rsquo;ve had to teach many others about Spring and common questions come up:\n What exactly is Spring (and Spring Boot) Why is there so much \u0026lsquo;magic\u0026rsquo; (beans) going on? Isn\u0026rsquo;t Java a dead language?   To clarify, I\u0026rsquo;m not here to convince anyone that \u0026ldquo;Spring is awesome and suits every project\u0026rdquo;. But over the next few posts I do want to lower the bar for getting started.\n What is Spring? Here\u0026rsquo;s what the Spring docs have to say:\n Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an applicationâ€™s needs.\n That\u0026rsquo;s fairly wordy but essentially its a framework for making enterprise applications. It can be further extended with Modules which are community driven. When people say \u0026ldquo;Spring\u0026rdquo; they refer to not just the Spring Framework but also to the modules built on top of it - the Spring stack or ecosystem.\nThis has the advantage of having many options but can also be very frustrating to newcomers.\nWhat does Spring mean by \u0026lsquo;Enterprise\u0026rsquo;? I\u0026rsquo;m not sure why Spring insists on name dropping enterprise as it can turn off many smaller developers and make the framework appear \u0026lsquo;heavy\u0026rsquo;.\nI would assert that many common enterprise problems are problems anyone faces when taking a project from their laptop to production:\n Support multiple deployment environments. In enterprise land this means not having direct access to production. Even if you do, you shouldn\u0026rsquo;t. Dependency injection and inversion of control. In the world of enterprise this can be different LDAP implementations, but even a local developer benefits by having a mock third party integration when running locally vs a real one in production. Transaction management. Many enterprises demand proper transactions around SQL updates, this is just good practice at any scale.  Who owns Spring? The framework is entirely Open Source and has an Apache 2.0 license. It is \u0026lsquo;free\u0026rsquo; as in beer.\nFrom an ownership perspective, the original founders' company - Spring (previously SpringSource) was brought by Pivitol Software which it self is now VMware Tanzu Labs.\nLooking at the contributors graph for Spring you\u0026rsquo;ll see VMware/Pivitol staff as the main core contributors.\n TLDR; Its open source but VMware owns the trademark.\n What is Spring Boot I hear people describe Spring Boot like this:\n Spring Boot is a bootstrap project (hence the name) maintained by the Spring team. It has sensible defaults already set and is designed to get going as quickly as possible.\n And I mostly agree. Its similar to Ruby on Rails or Create React App in that it gives you a stack to get going quickly.\nTypically people will use the Spring Initializr and choose additional dependencies such as Spring Web for a RESTful service with built in Apache Tomcat Server and Spring Security for authorization and authentication.\nThis is all nice, but in reality the biggest advantages when using Spring Boot is:\n All projects have a familiar structure. Common tasks (such as setting up logging, IoC, Maven, environment settings, etc) are setup saving time.  The second point is nice, but the first should be repeated:\n A common opinionated view way of working is a game changer when choosing a technology and forming a team.\n What Spring isn\u0026rsquo;t I would assert that a project (aka module) being in the Spring Framework is not any kind of seal of quality. Some projects are far more popular and well funded than others.\nIt\u0026rsquo;s not impossible for projects to leave the framework.\nRemember, it\u0026rsquo;s a collection of projects and modules. It\u0026rsquo;s down to experience to pick the ones right for you. Spring is only heavy if you want it to be.\n","permalink":"https://tombeckett.github.io/posts/spring-introduction/","summary":"Five years ago I moved to Spring Boot from ASP.NET. Frankly, I found Java and the Spring Framework confusing and it was not my choice to use it.\nSince then I\u0026rsquo;ve used many other backend technologies (Ruby on Rails, ASP.NET Core, Express/TypeScript) but I keep coming back to Spring. I\u0026rsquo;ve really had a change of heart with Spring.\nOver those years I\u0026rsquo;ve had to teach many others about Spring and common questions come up:","title":"Spring Boot: A quick introduction"},{"content":"I don\u0026rsquo;t really like blogging as a concept. My reaction is due to the tech world insisting every engineer should be blogging and how you should feel bad if you don\u0026rsquo;t. I\u0026rsquo;m a fairly private person with little to no online presence.\nDespite this I\u0026rsquo;ve wanted to blog for a few years. As a side effect, I\u0026rsquo;m pretty guilty for sending my friends walls of text about my diehard feelings on various tech topics. They reply suggesting I start a blog - I suspect as a coping mechanism.\nTheres a few reasons I feel apprehensive about blogging:\n I don\u0026rsquo;t feel like my writing skills are up to task. I\u0026rsquo;m not sure if my ideas are interesting enough for an entire lengthy post. It feels hipster and a bit look at me. I\u0026rsquo;m afraid that I\u0026rsquo;ll stop and people will see a blog thats clearly failed. Bloggers seems obsessed with making money.  For me it all comes down to motivation. I\u0026rsquo;ll blog only when I have something interesting to say. There wont be a regular schedule but when I do post I hope its interesting.\n","permalink":"https://tombeckett.github.io/posts/why-blog/","summary":"I don\u0026rsquo;t really like blogging as a concept. My reaction is due to the tech world insisting every engineer should be blogging and how you should feel bad if you don\u0026rsquo;t. I\u0026rsquo;m a fairly private person with little to no online presence.\nDespite this I\u0026rsquo;ve wanted to blog for a few years. As a side effect, I\u0026rsquo;m pretty guilty for sending my friends walls of text about my diehard feelings on various tech topics.","title":"Why blog? Why now?"}]