<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>I've stopped using continuous delivery | Tom Beckett</title><meta name=keywords content="technology,github actions"><meta name=description content="Every project I have configured over the last five or so years has used continuous deployment.
Here is how Atlassian describes it:
Continuous deployment goes one step further than continuous delivery. With this practice, every change that passes all stages of your production pipeline is released to your customers. There&rsquo;s no human intervention, and only a failed test will prevent a new change to be deployed to production.
Continuous deployment is an excellent way to accelerate the feedback loop with your customers and take pressure off the team as there isn&rsquo;t a &ldquo;release day&rdquo; anymore."><meta name=author content="Tom Beckett"><link rel=canonical href=https://tombeckett.github.io/posts/continous-delivery/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.612a587c75dbaa6349d632572927d1b3e50ae108eaa982ebbc7782882e385faf.css integrity="sha256-YSpYfHXbqmNJ1jJXKSfRs+UK4QjqqYLrvHeCiC44X68=" rel="preload stylesheet" as=style><link rel=icon href=https://tombeckett.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://tombeckett.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://tombeckett.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://tombeckett.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://tombeckett.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.105.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="I've stopped using continuous delivery"><meta property="og:description" content="Every project I have configured over the last five or so years has used continuous deployment.
Here is how Atlassian describes it:
Continuous deployment goes one step further than continuous delivery. With this practice, every change that passes all stages of your production pipeline is released to your customers. There&rsquo;s no human intervention, and only a failed test will prevent a new change to be deployed to production.
Continuous deployment is an excellent way to accelerate the feedback loop with your customers and take pressure off the team as there isn&rsquo;t a &ldquo;release day&rdquo; anymore."><meta property="og:type" content="article"><meta property="og:url" content="https://tombeckett.github.io/posts/continous-delivery/"><meta property="og:image" content="https://tombeckett.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-29T01:00:00+00:00"><meta property="article:modified_time" content="2022-10-29T01:00:00+00:00"><meta property="og:site_name" content="Tom Beckett"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://tombeckett.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="I've stopped using continuous delivery"><meta name=twitter:description content="Every project I have configured over the last five or so years has used continuous deployment.
Here is how Atlassian describes it:
Continuous deployment goes one step further than continuous delivery. With this practice, every change that passes all stages of your production pipeline is released to your customers. There&rsquo;s no human intervention, and only a failed test will prevent a new change to be deployed to production.
Continuous deployment is an excellent way to accelerate the feedback loop with your customers and take pressure off the team as there isn&rsquo;t a &ldquo;release day&rdquo; anymore."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://tombeckett.github.io/posts/"},{"@type":"ListItem","position":2,"name":"I've stopped using continuous delivery","item":"https://tombeckett.github.io/posts/continous-delivery/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"I've stopped using continuous delivery","name":"I\u0027ve stopped using continuous delivery","description":"Every project I have configured over the last five or so years has used continuous deployment.\nHere is how Atlassian describes it:\nContinuous deployment goes one step further than continuous delivery. With this practice, every change that passes all stages of your production pipeline is released to your customers. There\u0026rsquo;s no human intervention, and only a failed test will prevent a new change to be deployed to production.\nContinuous deployment is an excellent way to accelerate the feedback loop with your customers and take pressure off the team as there isn\u0026rsquo;t a \u0026ldquo;release day\u0026rdquo; anymore.","keywords":["technology","github actions"],"articleBody":"Every project I have configured over the last five or so years has used continuous deployment.\nHere is how Atlassian describes it:\nContinuous deployment goes one step further than continuous delivery. With this practice, every change that passes all stages of your production pipeline is released to your customers. There’s no human intervention, and only a failed test will prevent a new change to be deployed to production.\nContinuous deployment is an excellent way to accelerate the feedback loop with your customers and take pressure off the team as there isn’t a “release day” anymore. Developers can focus on building software, and they see their work go live minutes after they’ve finished working on it.\nIt’s fair to say I am a fan.\nContinuous deployment has four ideas that greatly appeal to me:\nDeployment is fast (and therefore cheap). Automated testing is sufficient. The smallest change possible between deployments is also safest. If a bug is found, it is quick and easy to release a new version and understand which commit caused the issue (hint - its probably the last one). On its surface this seems elegantly simple but I’ve learnt it has its trade offs.\nNo matter how fast, we don’t always want a release There are many times you merge a pull request but don’t actually want or need a release. These can be new assets, documentation updates, code coverage configuration, changes to a development deployment pipeline, etc.\nI’ve seen a few ways that developers respond to these unwanted builds:\nCancel unwanted builds: Causing insignificant amount runner wastage across organizations even if you’re fast. Add various path ignores to the deployment trigger: Introducing path globs across almost-duplicated workflows that only differ in ignored environment specific file paths. Merge changes in a release PR: Developers side step builds by to merging non-deployment commits into a single PR along with a change they do want to deploy. This breaks the smaller changes between deployments goal. We need to drop this assumption that every merge is a deliverable that needs to be deployed. The reality is that there a lot of churn that takes place in a repository and its not easy to automate it away.\nAutomated testing is not sufficient and smaller releases are not safer Anyone who has used dependabot on a JavaScript project has experienced the pain of almost daily library updates.\nI think is especially prevalent in the JavaScript ecosystem since many library developers are also website developers where continuous deployment makes sense.\nHowever, libraries are not websites. A regular release cadence with manual testing is far more preferable to merge -\u003e automated test -\u003e automated release.\nThis is further compounded by fixes can only move forward where you (the library consumer) feel stuck within a new feature release -\u003e bug fix release cycle.\nWhen to use it Continuous delivery can work when:\nYour users are happy to manually test for you Releasing requires no action on the part of users. The churn of non-deployment code (docs, config, etc) is far lower than your features/fixes. Should any of this change, I recommend giving up some agility for stability.\nWhat to use otherwise I recommend keeping change log of unreleased changes and a semantic version in a package.json, pom.xml type file.\nWhen its time to release:\nMerge in a pull request that moves the unreleased entries to a new version heading (which matches the semantic version) Manually trigger a workflow against the appropriate branch: git tag using the release (the semver from the file), Create a GitHub Release with entries from the CHANGELOG.md file Perform the automated deployment. This is not a radical approach and it’s been used by large projects for a long time.\nI’ve learnt that to go faster, you actually need to go slower sometimes.\n","wordCount":"630","inLanguage":"en","datePublished":"2022-10-29T01:00:00Z","dateModified":"2022-10-29T01:00:00Z","author":{"@type":"Person","name":"Tom Beckett"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tombeckett.github.io/posts/continous-delivery/"},"publisher":{"@type":"Organization","name":"Tom Beckett","logo":{"@type":"ImageObject","url":"https://tombeckett.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tombeckett.github.io/ accesskey=h title="Tom Beckett (Alt + H)">Tom Beckett</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://tombeckett.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://tombeckett.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://tombeckett.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tombeckett.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://tombeckett.github.io/posts/>Posts</a></div><h1 class=post-title>I've stopped using continuous delivery</h1><div class=post-meta><span title='2022-10-29 01:00:00 +0000 UTC'>October 29, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Tom Beckett&nbsp;|&nbsp;<a href=https://github.com/TomBeckett/tombeckett.github.io/tree/main/content/posts/continous-delivery.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Every project I have configured over the last five or so years has used <a href=https://en.wikipedia.org/wiki/Continuous_deployment>continuous deployment</a>.</p><p>Here is how <a href=https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment>Atlassian</a> describes it:</p><blockquote><p>Continuous deployment goes one step further than continuous delivery. With this practice, every change that passes all stages of your production pipeline is released to your customers. There&rsquo;s no human intervention, and only a failed test will prevent a new change to be deployed to production.</p><p>Continuous deployment is an excellent way to accelerate the feedback loop with your customers and take pressure off the team as there isn&rsquo;t a &ldquo;release day&rdquo; anymore. Developers can focus on building software, and they see their work go live minutes after they&rsquo;ve finished working on it.</p></blockquote><p>It&rsquo;s fair to say I am <em>a fan</em>.</p><p>Continuous deployment has four ideas that greatly appeal to me:</p><ul><li>Deployment is <strong>fast</strong> (and therefore cheap).</li><li>Automated testing is sufficient.</li><li>The smallest change possible between deployments is also <strong>safest</strong>.</li><li>If a bug is found, it is quick and easy to release a new version and understand which commit caused the issue <em>(hint - its probably the last one)</em>.</li></ul><p>On its surface this seems elegantly simple but I&rsquo;ve learnt it has its trade offs.</p><h2 id=no-matter-how-fast-we-dont-always-want-a-release>No matter how fast, we don&rsquo;t always want a release<a hidden class=anchor aria-hidden=true href=#no-matter-how-fast-we-dont-always-want-a-release>#</a></h2><p>There are many times you merge a pull request but don&rsquo;t actually want or need a release. These can be new assets, documentation updates, code coverage configuration, changes to a development deployment pipeline, etc.</p><p>I&rsquo;ve seen a few ways that developers respond to these unwanted builds:</p><ul><li><strong>Cancel unwanted builds</strong>: Causing insignificant amount runner wastage across organizations even if you&rsquo;re fast.</li><li><strong>Add various path ignores to the deployment trigger</strong>: Introducing path globs across almost-duplicated workflows that only differ in ignored environment specific file paths.</li><li><strong>Merge changes in a release PR</strong>: Developers side step builds by to merging non-deployment commits into a single PR along with a change they <strong>do</strong> want to deploy. This breaks the <em>smaller changes between deployments</em> goal.</li></ul><p>We need to drop this assumption that <em>every</em> merge is a deliverable that needs to be deployed. The reality is that there a lot of churn that takes place in a repository and its not easy to automate it away.</p><h2 id=automated-testing-is-not-sufficient-and-smaller-releases-are-not-safer>Automated testing is not sufficient and smaller releases are not safer<a hidden class=anchor aria-hidden=true href=#automated-testing-is-not-sufficient-and-smaller-releases-are-not-safer>#</a></h2><p>Anyone who has used <a href=https://github.com/dependabot>dependabot</a> on a JavaScript project has experienced the pain of almost <a href=https://imgur.com/C9iUXNW.png>daily library updates</a>.</p><p>I think is especially prevalent in the JavaScript ecosystem since many library developers are also website developers <em>where continuous deployment makes sense</em>.</p><p>However, libraries are not websites. A regular release cadence with manual testing is far more preferable to <strong>merge -> automated test -> automated release</strong>.</p><p>This is further compounded by <strong>fixes can only move forward</strong> where you (the library consumer) feel stuck within a <strong>new feature release -> bug fix release</strong> cycle.</p><h2 id=when-to-use-it>When to use it<a hidden class=anchor aria-hidden=true href=#when-to-use-it>#</a></h2><p>Continuous delivery can work when:</p><ul><li>Your users are happy to manually test for you</li><li>Releasing requires no action on the part of users.</li><li>The churn of non-deployment code (docs, config, etc) is far lower than your features/fixes.</li></ul><p>Should any of this change, I recommend <strong>giving up some agility for stability</strong>.</p><h2 id=what-to-use-otherwise>What to use otherwise<a hidden class=anchor aria-hidden=true href=#what-to-use-otherwise>#</a></h2><p>I recommend <a href=https://keepachangelog.com/en/1.0.0/>keeping change log</a> of unreleased changes and a <a href=https://semver.org/spec/v2.0.0.html>semantic version</a> in a <code>package.json</code>, <code>pom.xml</code> type file.</p><p>When its time to release:</p><ol><li>Merge in a pull request that moves the unreleased entries to a new version heading (which matches the semantic version)</li><li><a href=https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow>Manually trigger a workflow</a> against the appropriate branch:<ul><li><code>git tag</code> using the release (the semver from the file),</li><li>Create a GitHub Release with entries from the <code>CHANGELOG.md</code> file</li><li>Perform the automated deployment.</li></ul></li></ol><p>This is not a radical approach and it&rsquo;s been used by large projects for a long time.</p><p>I&rsquo;ve learnt that to go faster, you actually need to go slower sometimes.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tombeckett.github.io/tags/technology/>technology</a></li><li><a href=https://tombeckett.github.io/tags/github-actions/>github actions</a></li></ul><nav class=paginav><a class=next href=https://tombeckett.github.io/posts/junior-dev/><span class=title>Next Page »</span><br><span>How do I know if Im a Junior Dev?</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>